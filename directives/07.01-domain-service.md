# Direttiva 07.01 â€” Domain Entities + Repository + Dashboard Service + DAO Queries + Test

**Obiettivo:** Creare le entitÃ  di dominio per dashboard e report, l'interfaccia repository, il servizio di calcolo score/alert, e le query DAO mancanti. Validare con 8 test unitari.

**CriticitÃ :** ðŸŸ¡ MEDIO â€” Contiene la business logic core (score + alert). Errori qui propagano a tutta la UI.

**Prerequisiti:** Direttive 05 e 06 completate. Database con tabelle `transactions`, `accounts`, `chain_events` funzionanti.

**Dipendenze:** Nessuna sotto-direttiva precedente. Questa Ã¨ la base.

---

## Input

- `FIDELUX.md` sezione 4.4 (FideLux Score)
- `FIDELUX.md` sezione 4.5 (Sistema di Alert â€” 4 livelli)
- `directives/07-dashboard.md` Step 1 + Step 2 (entitÃ  + servizio)
- DAO esistenti: `lib/data/local_db/daos/transactions_dao.dart`, `accounts_dao.dart`

## Output Atteso

1. `lib/domain/entities/dashboard_data.dart` â€” DashboardData, ActiveAlert, ScoreLevel, ScoreTrend, AlertLevel
2. `lib/domain/entities/report_data.dart` â€” ReportData, MonthTotal, MerchantTotal, ReportPeriod, DateRange
3. `lib/domain/repositories/dashboard_repository.dart` â€” interfaccia astratta
4. `lib/data/dashboard/dashboard_service.dart` â€” implementazione con calcolo score + alert
5. Query aggiunte a `TransactionsDao` e `AccountsDao`
6. `test/dashboard/dashboard_service_test.dart` â€” 8 test
7. `flutter analyze` clean, `flutter test test/dashboard/` green

---

## Step 1 â€” Domain Entities

### lib/domain/entities/dashboard_data.dart

```dart
enum ScoreLevel { high, medium, low }
enum ScoreTrend { up, down, stable }
enum AlertLevel { normal, advisory, critical, sos }

class DashboardData {
  final int totalBalance;                    // Centesimi, somma tutti i conti
  final int monthExpenses;                   // Centesimi, spese mese corrente (valore positivo)
  final int monthIncome;                     // Centesimi, entrate mese corrente
  final int transactionCount;                // Transazioni mese corrente
  final double documentationRate;            // 0.0-1.0
  final int documentedDays;                  // Giorni con almeno 1 transazione
  final int totalDays;                       // Giorni trascorsi nel mese
  final int fideluxScore;                    // 0-100
  final ScoreLevel scoreLevel;
  final ScoreTrend scoreTrend;
  final List<ActiveAlert> activeAlerts;
  final Map<TransactionCategory, int> categoryBreakdown; // Centesimi per categoria (solo spese)
  final DateTime lastUpdated;

  const DashboardData({...}); // Tutti i campi required
}

class ActiveAlert {
  final String id;                           // UUID generato
  final AlertLevel level;
  final String titleKey;                     // Chiave l10n (es. "alertGamblingDetected")
  final String descriptionKey;               // Chiave l10n con parametri
  final Map<String, String> descriptionParams; // Parametri per la stringa l10n
  final DateTime createdAt;
  final bool dismissed;

  const ActiveAlert({...});

  ActiveAlert copyWith({bool? dismissed});
}
```

<rules>
1. Le entitÃ  sono **pure Dart** â€” ZERO import Flutter. `TransactionCategory` Ã¨ giÃ  pure Dart (nessun import Flutter nell'enum base, solo nell'extension).
2. ERRORE: `TransactionCategory` importa `package:flutter/material.dart` per `IconData` e `Colors`. Le entitÃ  dashboard NON devono importare Flutter. Usare `String` come chiave nella `categoryBreakdown` map oppure importare la enum senza usarne le proprietÃ  Flutter.
   - Soluzione: `categoryBreakdown` usa `TransactionCategory` come chiave (l'enum Ã¨ nel domain). L'import di `material.dart` nel file `transaction_category.dart` Ã¨ un debito tecnico preesistente â€” NON correggerlo in questa sotto-direttiva.
3. `ActiveAlert.titleKey` e `descriptionKey` sono chiavi di localizzazione, non stringhe hardcoded. I parametri per le stringhe parametrizzate vanno in `descriptionParams`.
4. Tutti i campi sono `final` e il costruttore Ã¨ `const`.
5. `AlertLevel` ha ordinamento implicito: normal < advisory < critical < sos (l'ordine dell'enum in Dart).
</rules>

### lib/domain/entities/report_data.dart

```dart
enum ReportPeriod { month, quarter, year }

class DateRange {
  final DateTime start; // UTC, inizio giorno (00:00:00)
  final DateTime end;   // UTC, fine giorno (23:59:59)

  const DateRange({required this.start, required this.end});

  /// Crea un DateRange per il mese corrente (dal 1Â° a oggi)
  factory DateRange.currentMonth() { ... }

  /// Crea un DateRange per un ReportPeriod relativo a oggi
  factory DateRange.fromPeriod(ReportPeriod period) { ... }
}

class ReportData {
  final DateRange dateRange;
  final Map<TransactionCategory, int> categoryBreakdown; // Centesimi
  final Map<DateTime, int> dailyTotals;                  // Giorno (UTC, midnight) â†’ centesimi spese
  final List<MonthTotal> monthlyComparison;               // Max 3 mesi
  final List<MerchantTotal> topMerchants;                 // Top 5
  final int totalExpenses;                                // Centesimi
  final int totalIncome;                                  // Centesimi

  const ReportData({...});
}

class MonthTotal {
  final int year;
  final int month;          // 1-12
  final int expenses;       // Centesimi (positivo)
  final int income;         // Centesimi (positivo)

  const MonthTotal({...});
}

class MerchantTotal {
  final String merchant;
  final int totalAmount;    // Centesimi (positivo)
  final int transactionCount;

  const MerchantTotal({...});
}
```

<rules>
1. EntitÃ  pure Dart. Nessun import Flutter.
2. `DateRange.currentMonth()` calcola da `DateTime(now.year, now.month, 1)` a `DateTime.now()`, tutto UTC.
3. `DateRange.fromPeriod()`:
   - `month` â†’ mese corrente
   - `quarter` â†’ ultimi 3 mesi
   - `year` â†’ ultimi 12 mesi
4. `dailyTotals` usa chiavi normalizzate a mezzanotte UTC: `DateTime.utc(year, month, day)`.
5. `MonthTotal` Ã¨ un value object semplice, usato per il confronto mensile.
</rules>

---

## Step 2 â€” Dashboard Repository Interface

### lib/domain/repositories/dashboard_repository.dart

```dart
import '../entities/dashboard_data.dart';
import '../entities/report_data.dart';

abstract class DashboardRepository {
  /// Calcola tutti i dati della dashboard per il mese corrente
  Future<DashboardData> getDashboardData();

  /// Genera report per un periodo specificato
  Future<ReportData> getReportData(DateRange dateRange);

  /// Dismissa un alert (solo advisory)
  Future<void> dismissAlert(String alertId);
}
```

<rules>
1. Interfaccia nel domain layer â€” nessuna dipendenza da implementazione.
2. `getDashboardData()` include internamente il calcolo score e la generazione alert.
3. `getReportData()` accetta un `DateRange` generico, non un `ReportPeriod` â€” la conversione da period a date range avviene nel chiamante.
4. `dismissAlert()` per l'MVP puÃ² essere no-op o mantenere uno stato in memoria. Nella V1.0 salverÃ  su DB.
</rules>

---

## Step 3 â€” Query DAO Mancanti

### Aggiungere a `lib/data/local_db/daos/transactions_dao.dart`

```dart
/// Transazioni in un range di date (per dashboard e report)
Future<List<Transaction>> getTransactionsByDateRange(DateTime start, DateTime end) {
  return (select(transactions)
    ..where((t) => t.date.isBiggerOrEqualValue(start) & t.date.isSmallerThanValue(end))
    ..orderBy([(t) => OrderingTerm(expression: t.date, mode: OrderingMode.desc)]))
  .get();
}

/// Somma spese per categoria in un range di date
/// Restituisce coppie (category, totalAmount) dove amount Ã¨ negativo (spese)
Future<List<TypedResult>> getCategoryTotals(DateTime start, DateTime end) {
  final cat = transactions.category;
  final total = transactions.amount.sum();
  return (selectOnly(transactions)
    ..addColumns([cat, total])
    ..where(transactions.date.isBiggerOrEqualValue(start) &
            transactions.date.isSmallerThanValue(end) &
            transactions.amount.isSmallerThanValue(0)) // Solo spese (negative)
    ..groupBy([cat]))
  .get();
}

/// Somma spese giornaliere in un range di date
/// Per CustomPainter bar chart
Future<List<TypedResult>> getDailyTotals(DateTime start, DateTime end) {
  final day = transactions.date.date; // Drift: .date estrae solo la parte data
  final total = transactions.amount.sum();
  return (selectOnly(transactions)
    ..addColumns([day, total])
    ..where(transactions.date.isBiggerOrEqualValue(start) &
            transactions.date.isSmallerThanValue(end) &
            transactions.amount.isSmallerThanValue(0))
    ..groupBy([day]))
  .get();
}

/// Giorni unici con almeno una transazione in un range
Future<int> getDocumentedDaysCount(DateTime start, DateTime end) async {
  // Conta giorni distinti
  final txns = await getTransactionsByDateRange(start, end);
  final days = txns.map((t) => DateTime.utc(t.date.year, t.date.month, t.date.day)).toSet();
  return days.length;
}

/// Top merchant per spese in un range
Future<List<TypedResult>> getTopMerchants(DateTime start, DateTime end, {int limit = 5}) {
  final merchant = transactions.merchant;
  final total = transactions.amount.sum();
  final count = transactions.id.count();
  return (selectOnly(transactions)
    ..addColumns([merchant, total, count])
    ..where(transactions.date.isBiggerOrEqualValue(start) &
            transactions.date.isSmallerThanValue(end) &
            transactions.amount.isSmallerThanValue(0) &
            transactions.merchant.isNotNull())
    ..groupBy([merchant])
    ..orderBy([OrderingTerm(expression: total, mode: OrderingMode.asc)]) // PiÃ¹ negativo = piÃ¹ speso
    ..limit(limit))
  .get();
}

/// Transazioni per categoria specifica in un range di date (per alert spike detection)
Future<int> getCategoryTotal(TransactionCategory category, DateTime start, DateTime end) async {
  final total = transactions.amount.sum();
  final query = selectOnly(transactions)
    ..addColumns([total])
    ..where(transactions.category.equals(category) &
            transactions.date.isBiggerOrEqualValue(start) &
            transactions.date.isSmallerThanValue(end));
  final result = await query.getSingle();
  return (result.read(total) ?? 0).abs();
}

/// Conta transazioni cash in un periodo (per alert prelievi multipli)
Future<List<Transaction>> getCashTransactionsInPeriod(DateTime start, DateTime end) {
  return (select(transactions)
    ..where((t) => t.category.equals(TransactionCategory.cash) &
                   t.date.isBiggerOrEqualValue(start) &
                   t.date.isSmallerThanValue(end))
    ..orderBy([(t) => OrderingTerm(expression: t.date, mode: OrderingMode.desc)]))
  .get();
}
```

### Aggiungere a `lib/data/local_db/daos/accounts_dao.dart`

```dart
/// Somma i saldi correnti di tutti i conti attivi
Future<int> getTotalBalance() async {
  final total = accounts.currentBalance.sum();
  final query = selectOnly(accounts)
    ..addColumns([total])
    ..where(accounts.isActive.equals(true));
  final result = await query.getSingle();
  return result.read(total) ?? 0;
}
```

<rules>
1. **Nota su Drift**: `transactions.date.date` potrebbe non funzionare direttamente per estrarre solo la parte data in SQLite. Se Drift non supporta `.date` su `DateTimeColumn`, usare l'approccio applicativo (fetch tutte le transazioni, raggruppare in Dart). Verificare con `flutter analyze`.
2. **Alternativa per `getDailyTotals`**: se le aggregazioni Drift sono complesse, implementare il raggruppamento in Dart nel `DashboardService` anzichÃ© nel DAO. L'importante Ã¨ che il DAO fornisca `getTransactionsByDateRange`.
3. Le query con `TypedResult` richiedono `selectOnly`. Il chiamante deve fare `result.read(columnExpression)` per estrarre i valori.
4. Il filtro `isSmallerThanValue(0)` seleziona solo spese (amount negativo nel DB).
5. **Non rimuovere** metodi DAO esistenti. Solo aggiungere.
6. Dopo le modifiche, eseguire `flutter pub run build_runner build --delete-conflicting-outputs` per rigenerare i file `.g.dart`.
</rules>

---

## Step 4 â€” Dashboard Service (Implementazione)

### lib/data/dashboard/dashboard_service.dart

```dart
import '../../domain/repositories/dashboard_repository.dart';
import '../../domain/entities/dashboard_data.dart';
import '../../domain/entities/report_data.dart';
import '../../domain/entities/transaction_category.dart';
import '../../data/local_db/daos/transactions_dao.dart';
import '../../data/local_db/daos/accounts_dao.dart';

class DashboardService implements DashboardRepository {
  final TransactionsDao _transactionsDao;
  final AccountsDao _accountsDao;

  // In-memory dismissed alerts (MVP â€” no persistence)
  final Set<String> _dismissedAlertIds = {};

  DashboardService(this._transactionsDao, this._accountsDao);

  @override
  Future<DashboardData> getDashboardData() async { ... }

  @override
  Future<ReportData> getReportData(DateRange dateRange) async { ... }

  @override
  Future<void> dismissAlert(String alertId) async {
    _dismissedAlertIds.add(alertId);
  }
}
```

<rules>
**FideLux Score MVP (2 componenti):**

```
Score = (documentationRate Ã— 50) + (regularityScore Ã— 50)
```

1. **Tasso documentazione (50%):** `documentedDays / daysElapsedInMonth Ã— 100`
   - `daysElapsedInMonth` = min(giorno corrente del mese, giorni totali del mese)
   - Se siamo al giorno 1 e c'Ã¨ almeno 1 transazione â†’ 100%
   - Se nessuna transazione â†’ 0%

2. **RegolaritÃ  (50%):**
   - Calcola il gap massimo tra giorni consecutivi con transazioni
   - Se maxGap â‰¤ 3 â†’ 100
   - Se maxGap 4-5 â†’ 70
   - Se maxGap 6-7 â†’ 40
   - Se maxGap > 7 â†’ 10
   - Se nessuna transazione â†’ 0

3. **Livelli:**
   - 70-100 â†’ `ScoreLevel.high`
   - 40-69 â†’ `ScoreLevel.medium`
   - 0-39 â†’ `ScoreLevel.low`

4. **Trend:** Confronta score mese corrente con score mese precedente.
   - Differenza > +5 â†’ `ScoreTrend.up`
   - Differenza < -5 â†’ `ScoreTrend.down`
   - Altrimenti â†’ `ScoreTrend.stable`
   - Se primo mese (no dati precedenti) â†’ `ScoreTrend.stable`

**Alert generation (ordine di prioritÃ ):**

1. Verifica se categoria `gambling` presente nel mese â†’ `AlertLevel.critical`
2. Verifica se 3+ transazioni `cash` in 24h â†’ `AlertLevel.critical`
3. Verifica se nessuna transazione da 3+ giorni â†’ `AlertLevel.advisory`
4. Verifica se una categoria ha superato 150% della media 2 mesi precedenti â†’ `AlertLevel.advisory`
   - Se non ci sono 2 mesi di storico, salta questo alert

**ID generazione alert:** Usa un ID deterministico basato su tipo + mese per evitare duplicati. Es: `"gambling_2026_02"`, `"cash_spike_2026_02_09"`, `"gap_3d_2026_02"`.

**`getReportData` implementazione:**
- Usa le query DAO per `categoryBreakdown`, `dailyTotals`, `topMerchants`
- Per `monthlyComparison`: calcola totali per mese corrente + 2 mesi precedenti
- Se le query aggregate Drift sono troppo complesse, fare il calcolo in Dart con le transazioni raw da `getTransactionsByDateRange`
</rules>

---

## Step 5 â€” Test

### test/dashboard/dashboard_service_test.dart

Setup: usa `AppDatabase.forTesting(NativeDatabase.memory())` come in `test/integration/accounting_flow_test.dart`. Mock non necessario â€” il servizio usa direttamente i DAO con DB in memoria.

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:drift/native.dart';
import 'package:fidelux/data/local_db/app_database.dart';
import 'package:fidelux/data/local_db/daos/transactions_dao.dart';
import 'package:fidelux/data/local_db/daos/accounts_dao.dart';
import 'package:fidelux/data/dashboard/dashboard_service.dart';
import 'package:fidelux/domain/entities/dashboard_data.dart';
import 'package:fidelux/domain/entities/transaction_category.dart';

void main() {
  late AppDatabase db;
  late TransactionsDao txDao;
  late AccountsDao accDao;
  late DashboardService service;

  setUp(() {
    db = AppDatabase.forTesting(NativeDatabase.memory());
    txDao = TransactionsDao(db);
    accDao = AccountsDao(db);
    service = DashboardService(txDao, accDao);
  });

  tearDown(() async => await db.close());

  // Helper per inserire un conto + transazioni di test
  // ...
}
```

**8 test richiesti:**

```
1. "calculates score with full documentation"
   Setup: transazione ogni giorno del mese fino ad oggi
   Expected: documentationRate â‰ˆ 1.0, score â‰¥ 90, scoreLevel == ScoreLevel.high

2. "calculates score with gaps"
   Setup: transazioni 20/31 giorni, gap max = 4 giorni
   Expected: score â‰ˆ 50-70, scoreLevel == ScoreLevel.medium

3. "calculates score with poor documentation"
   Setup: solo 3 transazioni in 3 giorni, gap > 7
   Expected: score < 40, scoreLevel == ScoreLevel.low

4. "detects trend up"
   Setup: mese corrente score alto, mese precedente score basso (poche transazioni)
   Expected: scoreTrend == ScoreTrend.up

5. "generates advisory alert for category spike"
   Setup: 2 mesi precedenti con entertainment media 5000 centesimi, mese corrente 15000
   Expected: almeno un alert con level == AlertLevel.advisory

6. "generates critical alert for multiple cash withdrawals"
   Setup: 3 transazioni cash nello stesso giorno (entro 24h)
   Expected: almeno un alert con level == AlertLevel.critical

7. "generates critical alert for gambling"
   Setup: una transazione con category == TransactionCategory.gambling
   Expected: almeno un alert con level == AlertLevel.critical

8. "no alerts when everything normal"
   Setup: transazioni regolari, nessun cash multiplo, nessun gambling, nessun spike
   Expected: activeAlerts.isEmpty (o solo normal)
```

<rules>
1. Ogni test deve creare prima un account (serve per il foreign key `accountId` nelle transazioni) e poi inserire transazioni con i dati appropriati.
2. Le transazioni necessitano anche di un `chain_event` collegato (foreign key `chainEventSequence`). Inserire un evento catena fittizio prima di ogni transazione.
3. Usare date UTC esplicite, non `DateTime.now()`, per rendere i test deterministici. Eccezione: per il "mese corrente" il servizio usa `DateTime.now()`, quindi i dati di test devono essere nel mese corrente.
4. Importi in centesimi. Spese come numeri negativi.
5. I test NON richiedono Flutter (`flutter_test` Ã¨ ok per test puri Dart).
6. Se il servizio usa `DateTime.now()` internamente, i test inseriscono dati nel mese/anno corrente per allinearsi.
</rules>

---

## Validazione

```bash
flutter pub run build_runner build --delete-conflicting-outputs   # Rigenera DAO
flutter analyze
flutter test test/dashboard/
```

Checklist:
- [ ] `DashboardData` e `ReportData` compilano senza import Flutter
- [ ] `DashboardRepository` Ã¨ nel domain layer
- [ ] `DashboardService` implementa `DashboardRepository`
- [ ] Nuove query DAO non rompono query esistenti
- [ ] build_runner genera senza errori
- [ ] 8/8 test passano
- [ ] `flutter analyze` clean

---

## Prossimo Modulo

â†’ `directives/07.02-usecases-providers-l10n.md` (Use cases, providers, localizzazione)
