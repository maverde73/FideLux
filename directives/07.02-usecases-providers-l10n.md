# Direttiva 07.02 â€” Use Cases + Providers + Localizzazione

**Obiettivo:** Creare gli use case per dashboard e report, i provider Riverpod, e aggiungere tutte le stringhe localizzate (EN/IT) necessarie per le schermate dashboard e report.

**CriticitÃ :** ðŸŸ¢ BASSO â€” Wiring layer, nessuna logica di business nuova.

**Prerequisiti:** Direttiva 07.01 completata. `DashboardService`, entitÃ , e DAO queries funzionanti.

**Dipendenze:** 07.01 (domain entities + service)

---

## Input

- `directives/07-dashboard.md` Step 3, Step 7, Step 8
- `lib/data/dashboard/dashboard_service.dart` (da 07.01)
- Pattern provider esistente: `lib/presentation/providers/accounting_providers.dart`
- Pattern use case esistente: `lib/application/accounting/get_account_summary.dart`

## Output Atteso

1. `lib/application/dashboard/get_dashboard_data.dart`
2. `lib/application/dashboard/get_report_data.dart`
3. `lib/presentation/providers/dashboard_providers.dart`
4. `lib/presentation/providers/report_providers.dart`
5. Stringhe aggiunte a `lib/l10n/app_en.arb` e `lib/l10n/app_it.arb`
6. `flutter gen-l10n` completato senza errori
7. `flutter analyze` clean

---

## Step 1 â€” Use Cases

### lib/application/dashboard/get_dashboard_data.dart

```dart
import '../../domain/repositories/dashboard_repository.dart';
import '../../domain/entities/dashboard_data.dart';

class GetDashboardData {
  final DashboardRepository _repository;

  GetDashboardData(this._repository);

  Future<DashboardData> call() {
    return _repository.getDashboardData();
  }
}
```

### lib/application/dashboard/get_report_data.dart

```dart
import '../../domain/repositories/dashboard_repository.dart';
import '../../domain/entities/report_data.dart';

class GetReportData {
  final DashboardRepository _repository;

  GetReportData(this._repository);

  Future<ReportData> call(DateRange dateRange) {
    return _repository.getReportData(dateRange);
  }
}
```

<rules>
1. Ogni use case Ã¨ una singola classe con un metodo `call()`.
2. Il use case non contiene logica â€” delega al repository.
3. I use case vivono nel layer `application/`, non nel `domain/` nÃ© nel `data/`.
4. Creare la directory `lib/application/dashboard/` se non esiste.
5. Seguire lo stesso pattern di `lib/application/accounting/get_account_summary.dart`.
</rules>

---

## Step 2 â€” Riverpod Providers

### lib/presentation/providers/dashboard_providers.dart

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/dashboard/dashboard_service.dart';
import '../../domain/repositories/dashboard_repository.dart';
import '../../domain/entities/dashboard_data.dart';
import '../../application/dashboard/get_dashboard_data.dart';
import 'accounting_providers.dart'; // Per transactionsDaoProvider, accountsDaoProvider

/// Provider per il DashboardRepository (DashboardService)
final dashboardRepositoryProvider = Provider<DashboardRepository>((ref) {
  final txDao = ref.watch(transactionsDaoProvider);
  final accDao = ref.watch(accountsDaoProvider);
  return DashboardService(txDao, accDao);
});

/// Provider per il use case
final getDashboardDataUseCaseProvider = Provider<GetDashboardData>((ref) {
  return GetDashboardData(ref.watch(dashboardRepositoryProvider));
});

/// Provider principale per i dati dashboard
/// Usa FutureProvider per permettere loading/error states nella UI
final dashboardDataProvider = FutureProvider<DashboardData>((ref) async {
  final useCase = ref.read(getDashboardDataUseCaseProvider);
  return useCase();
});

/// Provider per il conteggio alert critici (per badge navigazione)
/// Derivato da dashboardDataProvider â€” si aggiorna automaticamente
final criticalAlertCountProvider = Provider<int>((ref) {
  final dashboardAsync = ref.watch(dashboardDataProvider);
  return dashboardAsync.whenOrNull(
    data: (data) => data.activeAlerts
      .where((a) => !a.dismissed &&
        (a.level == AlertLevel.critical || a.level == AlertLevel.sos))
      .length,
  ) ?? 0;
});
```

### lib/presentation/providers/report_providers.dart

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/entities/report_data.dart';
import '../../application/dashboard/get_report_data.dart';
import 'dashboard_providers.dart'; // Per dashboardRepositoryProvider

/// Periodo selezionato dall'utente nella schermata Report
final selectedPeriodProvider = StateProvider<ReportPeriod>((ref) => ReportPeriod.month);

/// Provider per il use case
final getReportDataUseCaseProvider = Provider<GetReportData>((ref) {
  return GetReportData(ref.watch(dashboardRepositoryProvider));
});

/// Provider per i dati report, reattivo al cambio periodo
final reportDataProvider = FutureProvider<ReportData>((ref) async {
  final period = ref.watch(selectedPeriodProvider);
  final useCase = ref.read(getReportDataUseCaseProvider);
  return useCase(DateRange.fromPeriod(period));
});
```

<rules>
1. `dashboardRepositoryProvider` Ã¨ un `Provider` (singleton) perchÃ© `DashboardService` Ã¨ stateless (a parte il set degli alert dismissati, che Ã¨ in-memory per l'MVP).
2. `dashboardDataProvider` Ã¨ un `FutureProvider` per supportare `AsyncValue` nella UI (loading, error, data).
3. `criticalAlertCountProvider` Ã¨ un `Provider<int>` derivato â€” la UI lo usa per il badge, si aggiorna quando `dashboardDataProvider` cambia.
4. `reportDataProvider` usa `ref.watch(selectedPeriodProvider)` per ricalcolare quando l'utente cambia periodo.
5. **Non usare** `ref.watch` per i DAO dentro il repository provider â€” usare `ref.watch` Ã¨ corretto qui perchÃ© i DAO sono stabili (non cambiano).
6. Importare `AlertLevel` da `dashboard_data.dart` nel file `dashboard_providers.dart`.
</rules>

---

## Step 3 â€” Localizzazione

### Stringhe da aggiungere a `lib/l10n/app_en.arb`

Aggiungere **prima** della chiusura `}`, dopo l'ultima stringa esistente (`"gamblingAlert"`):

```json
  "dashboardTitle": "Dashboard",
  "dashboardScore": "FideLux Score",
  "dashboardScoreHigh": "Excellent",
  "dashboardScoreMedium": "Attention",
  "dashboardScoreLow": "Critical",
  "dashboardTotalBalance": "Total Balance",
  "dashboardMonthExpenses": "Month Expenses",
  "dashboardMonthIncome": "Month Income",
  "dashboardTransactions": "Transactions",
  "dashboardDocumentationRate": "Documentation Rate",
  "dashboardDocumentationDays": "{documented}/{total} days",
  "@dashboardDocumentationDays": {
    "placeholders": {
      "documented": { "type": "String" },
      "total": { "type": "String" }
    }
  },
  "dashboardTopCategories": "Top Categories",
  "dashboardViewAll": "View All",
  "dashboardNoData": "Start tracking to see your dashboard",
  "dashboardAlerts": "Active Alerts",
  "dashboardShowMoreAlerts": "Show {count} more",
  "@dashboardShowMoreAlerts": {
    "placeholders": {
      "count": { "type": "String" }
    }
  },
  "alertAdvisory": "Advisory",
  "alertCritical": "Critical",
  "alertSos": "SOS",
  "alertCategorySpike": "{category} is {percent}% above average",
  "@alertCategorySpike": {
    "placeholders": {
      "category": { "type": "String" },
      "percent": { "type": "String" }
    }
  },
  "alertNoDocumentation": "No transactions documented for {days} days",
  "@alertNoDocumentation": {
    "placeholders": {
      "days": { "type": "String" }
    }
  },
  "alertMultipleCashWithdrawals": "{count} cash withdrawals in 24 hours",
  "@alertMultipleCashWithdrawals": {
    "placeholders": {
      "count": { "type": "String" }
    }
  },
  "alertGamblingDetected": "Gambling transaction detected",
  "alertSosReceived": "SOS signal received from Sharer",
  "reportsTitle": "Reports",
  "reportsPeriodMonth": "Month",
  "reportsPeriodQuarter": "Quarter",
  "reportsPeriodYear": "Year",
  "reportsCategoryBreakdown": "Expenses by Category",
  "reportsDailyTrend": "Daily Trend",
  "reportsMonthlyComparison": "Monthly Comparison",
  "reportsTopMerchants": "Top Merchants",
  "reportsExportComingSoon": "Export PDF/CSV â€” Coming Soon",
  "reportsInsufficientData": "At least one month of data needed for full reports",
  "reportsTransactions": "{count} transactions",
  "@reportsTransactions": {
    "placeholders": {
      "count": { "type": "String" }
    }
  }
```

### Stringhe da aggiungere a `lib/l10n/app_it.arb`

```json
  "dashboardTitle": "Dashboard",
  "dashboardScore": "Punteggio FideLux",
  "dashboardScoreHigh": "Eccellente",
  "dashboardScoreMedium": "Attenzione",
  "dashboardScoreLow": "Critico",
  "dashboardTotalBalance": "Saldo Totale",
  "dashboardMonthExpenses": "Spese del Mese",
  "dashboardMonthIncome": "Entrate del Mese",
  "dashboardTransactions": "Transazioni",
  "dashboardDocumentationRate": "Tasso Documentazione",
  "dashboardDocumentationDays": "{documented}/{total} giorni",
  "@dashboardDocumentationDays": {
    "placeholders": {
      "documented": { "type": "String" },
      "total": { "type": "String" }
    }
  },
  "dashboardTopCategories": "Categorie Principali",
  "dashboardViewAll": "Vedi tutte",
  "dashboardNoData": "Inizia a tracciare per vedere la dashboard",
  "dashboardAlerts": "Alert Attivi",
  "dashboardShowMoreAlerts": "Mostra altri {count}",
  "@dashboardShowMoreAlerts": {
    "placeholders": {
      "count": { "type": "String" }
    }
  },
  "alertAdvisory": "Avviso",
  "alertCritical": "Critico",
  "alertSos": "SOS",
  "alertCategorySpike": "{category} Ã¨ {percent}% sopra la media",
  "@alertCategorySpike": {
    "placeholders": {
      "category": { "type": "String" },
      "percent": { "type": "String" }
    }
  },
  "alertNoDocumentation": "Nessuna transazione documentata da {days} giorni",
  "@alertNoDocumentation": {
    "placeholders": {
      "days": { "type": "String" }
    }
  },
  "alertMultipleCashWithdrawals": "{count} prelievi contanti in 24 ore",
  "@alertMultipleCashWithdrawals": {
    "placeholders": {
      "count": { "type": "String" }
    }
  },
  "alertGamblingDetected": "Rilevata transazione gioco d'azzardo",
  "alertSosReceived": "Segnale SOS ricevuto dall'Affidante",
  "reportsTitle": "Report",
  "reportsPeriodMonth": "Mese",
  "reportsPeriodQuarter": "Trimestre",
  "reportsPeriodYear": "Anno",
  "reportsCategoryBreakdown": "Spese per Categoria",
  "reportsDailyTrend": "Trend Giornaliero",
  "reportsMonthlyComparison": "Confronto Mensile",
  "reportsTopMerchants": "Esercenti Principali",
  "reportsExportComingSoon": "Export PDF/CSV â€” In arrivo",
  "reportsInsufficientData": "Serve almeno un mese di dati per i report completi",
  "reportsTransactions": "{count} transazioni",
  "@reportsTransactions": {
    "placeholders": {
      "count": { "type": "String" }
    }
  }
```

<rules>
1. Le stringhe con placeholder **devono** avere il corrispettivo `@keyName` con i metadati dei placeholder, sia in EN che in IT.
2. **Tipo placeholder**: usare `"type": "String"` per tutti. I numeri vengono passati come `toString()` dal codice Dart.
3. Non modificare le stringhe esistenti â€” solo aggiungere.
4. Assicurarsi che il JSON sia valido (virgola dopo l'ultima stringa esistente prima delle nuove, nessuna virgola dopo l'ultima stringa aggiunta, prima di `}`).
5. Dopo l'edit, eseguire `flutter gen-l10n` e verificare che `lib/l10n/generated/app_localizations_en.dart` e `_it.dart` contengano i nuovi getter.
6. Le chiavi `alertCategorySpike`, `alertNoDocumentation`, `alertMultipleCashWithdrawals` corrispondono ai `descriptionKey` usati in `ActiveAlert` dalla 07.01.
</rules>

---

## Validazione

```bash
flutter gen-l10n
flutter analyze
```

Checklist:
- [ ] Use case `GetDashboardData` compila e delega al repository
- [ ] Use case `GetReportData` compila e accetta `DateRange`
- [ ] `dashboardDataProvider` restituisce `FutureProvider<DashboardData>`
- [ ] `criticalAlertCountProvider` filtra correttamente per `critical` e `sos`
- [ ] `reportDataProvider` si aggiorna quando cambia `selectedPeriodProvider`
- [ ] `flutter gen-l10n` genera senza errori
- [ ] Tutte le 30+ chiavi di localizzazione presenti in EN e IT
- [ ] `flutter analyze` clean

---

## Prossimo Modulo

â†’ `directives/07.03-dashboard-ui.md` (Dashboard screen UI)
